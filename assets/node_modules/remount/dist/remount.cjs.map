{"version":3,"file":"remount.cjs","sources":["../src/strategies/custom_elements.js","../src/helpers/babel_es5_adapter.js","../src/each.js","../src/strategies/mutation_observer.js","../src/core.js","../node_modules/react-shadow-dom-retarget-events/index.js","../src/adapters/react.js","../src/index.js"],"sourcesContent":["// @ts-check\n/** @typedef { import('../types').Adapter } Adapter */\n/** @typedef { import('../types').Component } Component */\n/** @typedef { import('../types').Defaults } Defaults */\n/** @typedef { import('../types').ElementMap } ElementMap */\n/** @typedef { import('../types').ElementSpec } ElementSpec */\n/** @typedef { import('../types').ElementEvents } ElementEvents */\n/** @typedef { import('../types').ReactAdapter } ReactAdapter */\n/** @typedef { import('../types').PropertyMap } PropertyMap */\n\nimport { inject as enableBabelClasses } from '../helpers/babel_es5_adapter'\n\n/**\n * The name of this strategy.\n * @type string\n */\n\nexport const name = 'CustomElements'\n\n/**\n * Registers a custom element.\n *\n * This creates a custom element (ie, a subclass of `window.HTMLElement`) and\n * registers it (ie, `window.customElements.define`).\n *\n * Events will be triggered when something interesting happens.\n *\n * @example\n *     defineElement(\n *       { component: Tooltip },\n *       'x-tooltip',\n *       { onUpdate, onUnmount }\n *     )\n *\n * @private\n * @param {ElementSpec} elSpec\n * @param {string} elName\n * @param {ElementEvents} events\n */\n\nexport function defineElement(elSpec, elName, events) {\n  const { onUpdate, onUnmount, onMount } = events\n  enableBabelClasses()\n  const attributes = elSpec.attributes || []\n\n  class ComponentElement extends HTMLElement {\n    static get observedAttributes() {\n      return ['props-json', ...attributes]\n    }\n\n    connectedCallback() {\n      this._mountPoint = createMountPoint(this, elSpec)\n      onMount(this, this._mountPoint)\n    }\n\n    disconnectedCallback() {\n      if (!this._mountPoint) {\n        return\n      }\n      onUnmount(this, this._mountPoint)\n    }\n\n    attributeChangedCallback() {\n      if (!this._mountPoint) {\n        return\n      }\n      onUpdate(this, this._mountPoint)\n    }\n  }\n\n  // Supress warning when quiet mode is on\n  if (elSpec.quiet && window.customElements.get(elName)) {\n    return\n  }\n\n  window.customElements.define(elName, ComponentElement)\n}\n\nexport function isSupported() {\n  return !!(window.customElements && window.customElements.define)\n}\n\n/**\n * Creates a `<span>` element that serves as the mounting point for React\n * components. If `shadow: true` is requested, it'll attach a shadow node.\n *\n * @private\n * @param {HTMLElement} element\n * @param {ElementSpec} elSpec\n */\n\nfunction createMountPoint(element, elSpec) {\n  const { shadow } = elSpec\n  if (shadow && element.attachShadow) {\n    const mountPoint = document.createElement('span')\n    element.attachShadow({ mode: 'open' }).appendChild(mountPoint)\n    return mountPoint\n  } else {\n    return element\n  }\n}\n\n/**\n * Check if Shadow DOM is supported.\n */\n\nexport function supportsShadow() {\n  return !!(document && document.body && document.body.attachShadow)\n}\n","/* global HTMLElement */\n\n/*\n * Adapted from https://cdn.jsdelivr.net/npm/@webcomponents/webcomponentsjs@2.0.4/custom-elements-es5-adapter.js\n * Rolling this in so we don't need another polyfill.\n */\n\nexport function inject() {\n  if (\n    (window.HTMLElement && window.HTMLElement._babelES5Adapter) ||\n    void 0 === window.Reflect ||\n    void 0 === window.customElements ||\n    window.customElements.hasOwnProperty('polyfillWrapFlushCallback')\n  ) {\n    return\n  }\n  const a = HTMLElement\n\n  window.HTMLElement = function () {\n    return Reflect.construct(a, [], this.constructor)\n  }\n\n  HTMLElement.prototype = a.prototype\n  HTMLElement.prototype.constructor = HTMLElement\n  Object.setPrototypeOf(HTMLElement, a)\n  HTMLElement._babelES5Adapter = true\n}\n","// @ts-check\n\n/**\n * Some implementations of MutationObserver don't have .forEach,\n * so we need our own `forEach` shim. This is usually the case with\n * polyfilled environments.\n *\n * @type { import('./types').Each }\n */\n\nfunction each(/** @type any */ list, /** @type any */ fn) {\n  for (let i = 0, len = list.length; i < len; i++) {\n    fn(list[i])\n  }\n}\n\nexport default each\n","// @ts-check\n/** @typedef { import('../types').ElementSpec } ElementSpec */\n/** @typedef { import('../types').ElementEvents } ElementEvents */\n/** @typedef { import('../types').ObserverList } ObserverList */\n\nimport each from '../each'\n\n/**\n * The name of this strategy.\n * @type string\n */\n\nexport const name = 'MutationObserver'\n\n/**\n * List of observers tags.\n * @type ObserverList\n */\n\nexport const observers = {}\n\nexport function isSupported() {\n  return 'MutationObserver' in window\n}\n\n/**\n * Defines a custom element.\n *\n * @example\n *     defineElement(\n *       { component: MyComponent },\n *       'my-div',\n *       {\n *         onMount: () => {},\n *         onUpdate: () => {},\n *         onUnmount: () => {},\n *       }\n *     )\n *\n * @private\n * @param {ElementSpec} elSpec\n * @param {string} elName\n * @param {ElementEvents} events\n */\n\nexport function defineElement(elSpec, elName, events) {\n  elName = elName.toLowerCase()\n\n  // Maintain parity with what would happen in Custom Elements mode\n  if (!isValidName(elName)) {\n    if (elSpec.quiet) {\n      return\n    }\n    throw new Error(`Remount: \"${elName}\" is not a valid custom element elName`)\n  }\n\n  if (observers[elName]) {\n    if (elSpec.quiet) {\n      return\n    }\n    throw new Error(`Remount: \"${elName}\" is already registered`)\n  }\n\n  const observer = new MutationObserver(\n    /** @type MutationCallback */ (mutations) => {\n      each(mutations, (/** @type MutationRecord */ mutation) => {\n        each(mutation.addedNodes, (/** @type Node */ node) => {\n          if (isElement(node)) {\n            checkForMount(node, elName, events)\n          }\n        })\n      })\n    }\n  )\n\n  observer.observe(document.body, {\n    childList: true,\n    subtree: true\n  })\n\n  observers[name] = /* true */ observer\n\n  window.addEventListener('DOMContentLoaded', () => {\n    const nodes = document.getElementsByTagName(name)\n    each(nodes, (/** @type HTMLElement */ node) =>\n      checkForMount(node, name, events)\n    )\n  })\n}\n\n/**\n * Checks if this new element should fire an `onUpdate` hook.\n * Recurses down to its descendant nodes.\n *\n * @param {HTMLElement} node\n * @param {string} elName\n * @param {ElementEvents} events\n */\n\nfunction checkForMount(node, elName, events) {\n  if (node.nodeName.toLowerCase() === elName) {\n    // It's a match!\n    events.onMount(node, node)\n    observeForUpdates(node, events)\n    observeForRemoval(node, events)\n  } else if (node.children && node.children.length) {\n    // Recurse down into the other additions\n    each(node.children, (/** @type HTMLElement */ subnode) => {\n      if (isElement(subnode)) {\n        checkForMount(subnode, elName, events)\n      }\n    })\n  }\n}\n\n/**\n * Observes for any changes in attributes.\n *\n * @param {Element} node\n * @param {ElementEvents} events\n */\n\nfunction observeForUpdates(node, events) {\n  const { onUpdate } = events\n  const observer = new MutationObserver(\n    /** @type MutationCallback */ (mutations) => {\n      each(mutations, (/** @type MutationRecord */ mutation) => {\n        const targetNode = mutation.target\n        if (isElement(targetNode)) {\n          onUpdate(targetNode, targetNode)\n        }\n      })\n    }\n  )\n\n  observer.observe(node, { attributes: true })\n}\n\n/**\n * Observes a node's parent to wait until the node is removed\n * @param {HTMLElement} node\n * @param {ElementEvents} events\n */\n\nfunction observeForRemoval(node, events) {\n  const { onUnmount } = events\n  const parent = node.parentNode\n\n  // Not sure when this can happen, but let's add this for type safety\n  if (!parent) {\n    return\n  }\n\n  const observer = new MutationObserver(\n    /** @type MutationCallback */ (mutations) => {\n      each(mutations, (/** @type MutationRecord */ mutation) => {\n        each(mutation.removedNodes, (/** @type Node */ subnode) => {\n          if (node !== subnode) {\n            return\n          }\n          if (isElement(node)) {\n            // @ts-ignore TypeScript expects 0 arguments...?\n            observer.disconnect(parent)\n            onUnmount(node, node)\n          }\n        })\n      })\n    }\n  )\n\n  observer.observe(parent, { childList: true, subtree: true })\n}\n\n/**\n * Validate a custom tag.\n *\n * Since Remount can work with either Custom Elements or MutationObserver API's,\n * it'd be wise if we rejected element names that won't work in Custom Elements\n * mode (even if we're using MutationObserver mode).\n *\n * @param {string} elName\n * @returns {boolean}\n *\n * @example\n *     isValidName('div')      // => false\n *     isValidName('my-div')   // => true\n *     isValidName('123-456')  // => false\n *     isValidName('my-123')   // => true\n *\n * @private\n */\n\nfunction isValidName(elName) {\n  return !!(elName.indexOf('-') !== -1 && elName.match(/^[a-z][a-z0-9-]*$/))\n}\n\n/**\n * Shadow DOM is not supported with the Mutation Observer strategy.\n */\n\nexport function supportsShadow() {\n  return false\n}\n\n/**\n * Checks if a given Node is an HTMLElement.\n *\n * It's possible that a mutation's `addedNodes` return something that isn't an\n * HTMLElement.\n *\n * @param {any} node\n * @returns {node is HTMLElement}\n */\n\nfunction isElement(node) {\n  if (node) {\n    return true\n  }\n  return false\n}\n","// @ts-check\n/** @typedef { import('./types').Adapter } Adapter */\n/** @typedef { import('./types').Component } Component */\n/** @typedef { import('./types').Defaults } Defaults */\n/** @typedef { import('./types').ElementMap } ElementMap */\n/** @typedef { import('./types').ElementSpec } ElementSpec */\n/** @typedef { import('./types').PropertyMap } PropertyMap */\n/** @typedef { import('./types').Strategy } Strategy */\n\nimport * as CustomElementsStrategy from './strategies/custom_elements'\nimport * as MutationObserverStrategy from './strategies/mutation_observer'\n\n/**\n * Cache of the strategy determined by `getStrategy()`.\n * @type {Strategy | null | undefined}\n */\n\nlet cachedStrategy\n\n/**\n * Detect what API can be used.\n *\n * @example\n *     Remount.getStrategy().name\n */\n\nexport function getStrategy() {\n  if (cachedStrategy) {\n    return cachedStrategy\n  }\n\n  const StrategyUsed = [CustomElementsStrategy, MutationObserverStrategy].find(\n    (strategy) => !!strategy.isSupported()\n  )\n\n  if (!StrategyUsed) {\n    /* tslint:disable no-console */\n    console.warn(\n      \"Remount: This browser doesn't support the \" +\n      'MutationObserver API or the Custom Elements API. Including ' +\n      'polyfills might fix this. Remount elements will not work. ' +\n      'https://github.com/rstacruz/remount'\n    )\n  }\n\n  cachedStrategy = StrategyUsed\n  return StrategyUsed\n}\n\n/**\n * Registers custom elements and links them to React components.\n * @param {ElementMap} components\n * @param {Defaults=} defaults\n *\n * @example\n *     define({ 'x-tooltip': Tooltip })\n *\n * @example\n *     define(\n *       { 'x-tooltip': Tooltip },\n *       { attributes: ['title', 'body'] }\n *     )\n */\n\nexport function define(components, defaults) {\n  const Strategy = getStrategy()\n  if (!Strategy) {\n    return\n  }\n\n  Object.keys(components).forEach((/** @type string */ name) => {\n    // Construct the specs for the element.\n    // (eg, { component: Tooltip, attributes: ['title'] })\n    /** @type ElementSpec */\n    const elSpec = Object.assign({}, defaults, toElementSpec(components[name]))\n\n    /** @type Adapter | null | undefined */\n    const adapter = elSpec.adapter\n    if (!adapter) throw new Error('No suitable adapter found')\n\n    // Define a custom element.\n    Strategy.defineElement(elSpec, name, {\n      onMount(element, mountPoint) {\n        const props = getProps(element, elSpec.attributes)\n        if (elSpec.shadow && elSpec.retarget) {\n          adapter.mount(elSpec, mountPoint, props, element)\n        } else {\n          adapter.mount(elSpec, mountPoint, props, null)\n        }\n      },\n\n      onUpdate(element, mountPoint) {\n        const props = getProps(element, elSpec.attributes)\n        adapter.update(elSpec, mountPoint, props, null)\n      },\n\n      onUnmount(element, mountPoint) {\n        adapter.unmount(elSpec, mountPoint)\n      }\n    })\n  })\n}\n\n/**\n * Coerces something into an `ElementSpec` type.\n *\n * @param {ElementSpec | Component} thing\n * @returns {ElementSpec}\n * @private\n *\n * @example\n *     toElementSpec(Tooltip)\n *     // => { component: Tooltip }\n *\n *     toElementSpec({ component: Tooltip })\n *     // => { component: Tooltip }\n */\n\nfunction toElementSpec(thing) {\n  if (isElementSpec(thing)) {\n    return thing\n  }\n  return { component: thing }\n}\n\n/**\n * Checks if a given `spec` is an ElementSpec.\n *\n * @param {any} spec\n * @returns {spec is ElementSpec}\n */\n\nfunction isElementSpec(spec) {\n  return typeof spec === 'object' && spec.component\n}\n\n/**\n * Returns properties for a given HTML element.\n *\n * @private\n * @param {HTMLElement} element\n * @param {string[] | null | undefined} attributes\n *\n * @example\n *     getProps(div, ['name'])\n *     // => { name: 'Romeo' }\n */\n\nfunction getProps(element, attributes) {\n  const rawJson = element.getAttribute('props-json')\n  if (rawJson) {\n    return JSON.parse(rawJson)\n  }\n\n  const names = attributes || []\n  return names.reduce(\n    (/** @type PropertyMap */ result, /** @type string */ attribute) => {\n      result[attribute] = element.getAttribute(attribute)\n      return result\n    },\n    {}\n  )\n}\n\n/**\n * @param {Adapter} adapter\n */\n\nexport function defineWithAdapter(adapter) {\n  return (\n    /* @type {ElementMap} */ components = {},\n    /** @type {Defaults} */ options = {}\n  ) => define(components, { adapter, ...options })\n}\n","var reactEvents = [\"onAbort\", \"onAnimationCancel\", \"onAnimationEnd\", \"onAnimationIteration\", \"onAuxClick\", \"onBlur\",\n    \"onChange\", \"onClick\", \"onClose\", \"onContextMenu\", \"onDoubleClick\", \"onError\", \"onFocus\", \"onGotPointerCapture\",\n    \"onInput\", \"onKeyDown\", \"onKeyPress\", \"onKeyUp\", \"onLoad\", \"onLoadEnd\", \"onLoadStart\", \"onLostPointerCapture\",\n    \"onMouseDown\", \"onMouseMove\", \"onMouseOut\", \"onMouseOver\", \"onMouseUp\", \"onPointerCancel\", \"onPointerDown\",\n    \"onPointerEnter\", \"onPointerLeave\", \"onPointerMove\", \"onPointerOut\", \"onPointerOver\", \"onPointerUp\", \"onReset\",\n    \"onResize\", \"onScroll\", \"onSelect\", \"onSelectionChange\", \"onSelectStart\", \"onSubmit\", \"onTouchCancel\",\n    \"onTouchMove\", \"onTouchStart\", \"onTouchEnd\",\"onTransitionCancel\", \"onTransitionEnd\", \"onDrag\", \"onDragEnd\",\n    \"onDragEnter\", \"onDragExit\", \"onDragLeave\", \"onDragOver\", \"onDragStart\", \"onDrop\", \"onFocusOut\"];\n\nvar divergentNativeEvents = {\n    onDoubleClick: 'dblclick'\n};\n\nvar mimickedReactEvents = {\n    onInput: 'onChange',\n    onFocusOut: 'onBlur',\n    onSelectionChange: 'onSelect'\n};\n\nmodule.exports = function retargetEvents(shadowRoot) {\n    var removeEventListeners = [];\n\n    reactEvents.forEach(function (reactEventName) {\n\n        var nativeEventName = getNativeEventName(reactEventName);\n\n        function retargetEvent(event) {\n\n            var path = event.path || (event.composedPath && event.composedPath()) || composedPath(event.target);\n\n            for (var i = 0; i < path.length; i++) {\n\n                var el = path[i];\n                var props = null;\n                var reactComponent = findReactComponent(el);\n                var eventHandlers = findReactEventHandlers(el);\n\n                if (!eventHandlers) {\n                    props = findReactProps(reactComponent);\n                } else {\n                    props = eventHandlers;\n                }\n\n                if (reactComponent && props) {\n                    dispatchEvent(event, reactEventName, props);\n                }\n\n                if (reactComponent && props && mimickedReactEvents[reactEventName]) {\n                    dispatchEvent(event, mimickedReactEvents[reactEventName], props);\n                }\n\n                if (event.cancelBubble) {\n                    break;\n                }\n\n                if (el === shadowRoot) {\n                    break;\n                }\n            }\n        }\n\n        shadowRoot.addEventListener(nativeEventName, retargetEvent, false);\n\n        removeEventListeners.push(function () { shadowRoot.removeEventListener(nativeEventName, retargetEvent, false); })\n    });\n\n    return function () {\n\n      removeEventListeners.forEach(function (removeEventListener) {\n\n        removeEventListener();\n      });\n    };\n};\n\nfunction findReactEventHandlers(item) {\n    return findReactProperty(item, '__reactEventHandlers');\n}\n\nfunction findReactComponent(item) {\n    return findReactProperty(item, '_reactInternal');\n}\n\nfunction findReactProperty(item, propertyPrefix) {\n    for (var key in item) {\n        if (item.hasOwnProperty(key) && key.indexOf(propertyPrefix) !== -1) {\n            return item[key];\n        }\n    }\n}\n\nfunction findReactProps(component) {\n    if (!component) return undefined;\n    if (component.memoizedProps) return component.memoizedProps; // React 16 Fiber\n    if (component._currentElement && component._currentElement.props) return component._currentElement.props; // React <=15\n\n}\n\nfunction dispatchEvent(event, eventType, componentProps) {\n    event.persist = function() {\n        event.isPersistent = function(){ return true};\n    };\n\n    if (componentProps[eventType]) {\n        componentProps[eventType](event);\n    }\n}\n\nfunction getNativeEventName(reactEventName) {\n    if (divergentNativeEvents[reactEventName]) {\n        return divergentNativeEvents[reactEventName];\n    }\n    return reactEventName.replace(/^on/, '').toLowerCase();\n}\n\nfunction composedPath(el) {\n  var path = [];\n  while (el) {\n    path.push(el);\n    if (el.tagName === 'HTML') {\n      path.push(document);\n      path.push(window);\n      return path;\n    }\n    el = el.parentElement;\n  }\n}\n","// @ts-check\n/*\n * Adapter for React 18.\n */\n\n/** @typedef { import('../types').ElementSpec } ElementSpec */\n\nimport React from 'react'\nimport { createRoot } from 'react-dom/client'\nimport retargetEvents from 'react-shadow-dom-retarget-events'\n\n/**\n * @param {ElementSpec} elSpec\n * @param {HTMLElement} mountPoint\n * @param {object} props\n * @param {HTMLElement | null} element\n */\n\nexport function mount(elSpec, mountPoint, props, element) {\n  return update(elSpec, mountPoint, props, element)\n}\n\n/**\n * Updates a custom element by calling `ReactDOM.render()`.\n * @private\n *\n * @param {ElementSpec} elSpec\n * @param {HTMLElement & { __remountRoot?: any }} mountPoint\n * @param {object} props\n * @param {HTMLElement | null} element\n */\n\nexport function update(elSpec, mountPoint, props, element) {\n  const { component } = elSpec\n  const reactElement = React.createElement(component, props)\n  const root = createRoot(mountPoint)\n  /** @type {any} */ mountPoint.__remountRoot = root\n  root.render(reactElement)\n  if (element) {\n    retargetEvents(element.shadowRoot)\n  }\n}\n\n/**\n * Unmounts a component.\n * @private\n *\n * @param {ElementSpec} _elSpec\n * @param {HTMLElement & { __remountRoot?: any }} mountPoint\n */\n\nexport function unmount(_elSpec, mountPoint) {\n  mountPoint.__remountRoot?.unmount()\n}\n","/** @typedef { import('./types').ElementMap } ElementMap */\n/** @typedef { import('./types').Defaults } Defaults */\n\nimport { defineWithAdapter, getStrategy } from './core'\nimport * as ReactAdapter from './adapters/react'\n\nconst define = defineWithAdapter(ReactAdapter)\n\n// Alias for doing `import Remount from 'remount'` rather than `import * as Remount`\nconst Remount = { define, getStrategy }\nexport { define, getStrategy, Remount as default }\n"],"names":["elSpec","elName","events","onUpdate","onUnmount","onMount","window","HTMLElement","_babelES5Adapter","Reflect","customElements","hasOwnProperty","a","construct","this","constructor","prototype","Object","setPrototypeOf","enableBabelClasses","attributes","ComponentElement","_HTMLElement","apply","arguments","_proto","connectedCallback","_mountPoint","element","shadow","attachShadow","mountPoint","document","createElement","mode","appendChild","createMountPoint","disconnectedCallback","attributeChangedCallback","key","get","quiet","define","isSupported","body","each","list","fn","i","len","length","name","observers","checkForMount","node","nodeName","toLowerCase","MutationObserver","mutations","mutation","targetNode","target","isElement","observe","observeForUpdates","parent","parentNode","observer","removedNodes","subnode","disconnect","childList","subtree","observeForRemoval","children","cachedStrategy","indexOf","match","isValidName","Error","addedNodes","addEventListener","getElementsByTagName","supportsShadow","getStrategy","StrategyUsed","CustomElementsStrategy","MutationObserverStrategy","find","strategy","console","warn","getProps","rawJson","getAttribute","JSON","parse","reduce","result","attribute","reactEvents","divergentNativeEvents","onDoubleClick","mimickedReactEvents","onInput","onFocusOut","onSelectionChange","findReactProperty","item","propertyPrefix","findReactProps","component","memoizedProps","_currentElement","props","dispatchEvent","event","eventType","componentProps","persist","isPersistent","update","shadowRoot","removeEventListeners","reactElement","React","root","createRoot","__remountRoot","render","forEach","reactEventName","nativeEventName","replace","getNativeEventName","retargetEvent","path","composedPath","el","push","tagName","parentElement","reactComponent","cancelBubble","removeEventListener","adapter","unmount","_elSpec","_mountPoint$__remount","components","options","defaults","Strategy","keys","thing","spec","assign","defineElement","mount","retarget"],"mappings":"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"}