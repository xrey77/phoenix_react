{"version":3,"file":"remount.modern.js","sources":["../src/strategies/custom_elements.js","../src/helpers/babel_es5_adapter.js","../src/each.js","../src/strategies/mutation_observer.js","../src/core.js","../node_modules/react-shadow-dom-retarget-events/index.js","../src/adapters/react.js","../src/index.js"],"sourcesContent":["// @ts-check\n/** @typedef { import('../types').Adapter } Adapter */\n/** @typedef { import('../types').Component } Component */\n/** @typedef { import('../types').Defaults } Defaults */\n/** @typedef { import('../types').ElementMap } ElementMap */\n/** @typedef { import('../types').ElementSpec } ElementSpec */\n/** @typedef { import('../types').ElementEvents } ElementEvents */\n/** @typedef { import('../types').ReactAdapter } ReactAdapter */\n/** @typedef { import('../types').PropertyMap } PropertyMap */\n\nimport { inject as enableBabelClasses } from '../helpers/babel_es5_adapter'\n\n/**\n * The name of this strategy.\n * @type string\n */\n\nexport const name = 'CustomElements'\n\n/**\n * Registers a custom element.\n *\n * This creates a custom element (ie, a subclass of `window.HTMLElement`) and\n * registers it (ie, `window.customElements.define`).\n *\n * Events will be triggered when something interesting happens.\n *\n * @example\n *     defineElement(\n *       { component: Tooltip },\n *       'x-tooltip',\n *       { onUpdate, onUnmount }\n *     )\n *\n * @private\n * @param {ElementSpec} elSpec\n * @param {string} elName\n * @param {ElementEvents} events\n */\n\nexport function defineElement(elSpec, elName, events) {\n  const { onUpdate, onUnmount, onMount } = events\n  enableBabelClasses()\n  const attributes = elSpec.attributes || []\n\n  class ComponentElement extends HTMLElement {\n    static get observedAttributes() {\n      return ['props-json', ...attributes]\n    }\n\n    connectedCallback() {\n      this._mountPoint = createMountPoint(this, elSpec)\n      onMount(this, this._mountPoint)\n    }\n\n    disconnectedCallback() {\n      if (!this._mountPoint) {\n        return\n      }\n      onUnmount(this, this._mountPoint)\n    }\n\n    attributeChangedCallback() {\n      if (!this._mountPoint) {\n        return\n      }\n      onUpdate(this, this._mountPoint)\n    }\n  }\n\n  // Supress warning when quiet mode is on\n  if (elSpec.quiet && window.customElements.get(elName)) {\n    return\n  }\n\n  window.customElements.define(elName, ComponentElement)\n}\n\nexport function isSupported() {\n  return !!(window.customElements && window.customElements.define)\n}\n\n/**\n * Creates a `<span>` element that serves as the mounting point for React\n * components. If `shadow: true` is requested, it'll attach a shadow node.\n *\n * @private\n * @param {HTMLElement} element\n * @param {ElementSpec} elSpec\n */\n\nfunction createMountPoint(element, elSpec) {\n  const { shadow } = elSpec\n  if (shadow && element.attachShadow) {\n    const mountPoint = document.createElement('span')\n    element.attachShadow({ mode: 'open' }).appendChild(mountPoint)\n    return mountPoint\n  } else {\n    return element\n  }\n}\n\n/**\n * Check if Shadow DOM is supported.\n */\n\nexport function supportsShadow() {\n  return !!(document && document.body && document.body.attachShadow)\n}\n","/* global HTMLElement */\n\n/*\n * Adapted from https://cdn.jsdelivr.net/npm/@webcomponents/webcomponentsjs@2.0.4/custom-elements-es5-adapter.js\n * Rolling this in so we don't need another polyfill.\n */\n\nexport function inject() {\n  if (\n    (window.HTMLElement && window.HTMLElement._babelES5Adapter) ||\n    void 0 === window.Reflect ||\n    void 0 === window.customElements ||\n    window.customElements.hasOwnProperty('polyfillWrapFlushCallback')\n  ) {\n    return\n  }\n  const a = HTMLElement\n\n  window.HTMLElement = function () {\n    return Reflect.construct(a, [], this.constructor)\n  }\n\n  HTMLElement.prototype = a.prototype\n  HTMLElement.prototype.constructor = HTMLElement\n  Object.setPrototypeOf(HTMLElement, a)\n  HTMLElement._babelES5Adapter = true\n}\n","// @ts-check\n\n/**\n * Some implementations of MutationObserver don't have .forEach,\n * so we need our own `forEach` shim. This is usually the case with\n * polyfilled environments.\n *\n * @type { import('./types').Each }\n */\n\nfunction each(/** @type any */ list, /** @type any */ fn) {\n  for (let i = 0, len = list.length; i < len; i++) {\n    fn(list[i])\n  }\n}\n\nexport default each\n","// @ts-check\n/** @typedef { import('../types').ElementSpec } ElementSpec */\n/** @typedef { import('../types').ElementEvents } ElementEvents */\n/** @typedef { import('../types').ObserverList } ObserverList */\n\nimport each from '../each'\n\n/**\n * The name of this strategy.\n * @type string\n */\n\nexport const name = 'MutationObserver'\n\n/**\n * List of observers tags.\n * @type ObserverList\n */\n\nexport const observers = {}\n\nexport function isSupported() {\n  return 'MutationObserver' in window\n}\n\n/**\n * Defines a custom element.\n *\n * @example\n *     defineElement(\n *       { component: MyComponent },\n *       'my-div',\n *       {\n *         onMount: () => {},\n *         onUpdate: () => {},\n *         onUnmount: () => {},\n *       }\n *     )\n *\n * @private\n * @param {ElementSpec} elSpec\n * @param {string} elName\n * @param {ElementEvents} events\n */\n\nexport function defineElement(elSpec, elName, events) {\n  elName = elName.toLowerCase()\n\n  // Maintain parity with what would happen in Custom Elements mode\n  if (!isValidName(elName)) {\n    if (elSpec.quiet) {\n      return\n    }\n    throw new Error(`Remount: \"${elName}\" is not a valid custom element elName`)\n  }\n\n  if (observers[elName]) {\n    if (elSpec.quiet) {\n      return\n    }\n    throw new Error(`Remount: \"${elName}\" is already registered`)\n  }\n\n  const observer = new MutationObserver(\n    /** @type MutationCallback */ (mutations) => {\n      each(mutations, (/** @type MutationRecord */ mutation) => {\n        each(mutation.addedNodes, (/** @type Node */ node) => {\n          if (isElement(node)) {\n            checkForMount(node, elName, events)\n          }\n        })\n      })\n    }\n  )\n\n  observer.observe(document.body, {\n    childList: true,\n    subtree: true\n  })\n\n  observers[name] = /* true */ observer\n\n  window.addEventListener('DOMContentLoaded', () => {\n    const nodes = document.getElementsByTagName(name)\n    each(nodes, (/** @type HTMLElement */ node) =>\n      checkForMount(node, name, events)\n    )\n  })\n}\n\n/**\n * Checks if this new element should fire an `onUpdate` hook.\n * Recurses down to its descendant nodes.\n *\n * @param {HTMLElement} node\n * @param {string} elName\n * @param {ElementEvents} events\n */\n\nfunction checkForMount(node, elName, events) {\n  if (node.nodeName.toLowerCase() === elName) {\n    // It's a match!\n    events.onMount(node, node)\n    observeForUpdates(node, events)\n    observeForRemoval(node, events)\n  } else if (node.children && node.children.length) {\n    // Recurse down into the other additions\n    each(node.children, (/** @type HTMLElement */ subnode) => {\n      if (isElement(subnode)) {\n        checkForMount(subnode, elName, events)\n      }\n    })\n  }\n}\n\n/**\n * Observes for any changes in attributes.\n *\n * @param {Element} node\n * @param {ElementEvents} events\n */\n\nfunction observeForUpdates(node, events) {\n  const { onUpdate } = events\n  const observer = new MutationObserver(\n    /** @type MutationCallback */ (mutations) => {\n      each(mutations, (/** @type MutationRecord */ mutation) => {\n        const targetNode = mutation.target\n        if (isElement(targetNode)) {\n          onUpdate(targetNode, targetNode)\n        }\n      })\n    }\n  )\n\n  observer.observe(node, { attributes: true })\n}\n\n/**\n * Observes a node's parent to wait until the node is removed\n * @param {HTMLElement} node\n * @param {ElementEvents} events\n */\n\nfunction observeForRemoval(node, events) {\n  const { onUnmount } = events\n  const parent = node.parentNode\n\n  // Not sure when this can happen, but let's add this for type safety\n  if (!parent) {\n    return\n  }\n\n  const observer = new MutationObserver(\n    /** @type MutationCallback */ (mutations) => {\n      each(mutations, (/** @type MutationRecord */ mutation) => {\n        each(mutation.removedNodes, (/** @type Node */ subnode) => {\n          if (node !== subnode) {\n            return\n          }\n          if (isElement(node)) {\n            // @ts-ignore TypeScript expects 0 arguments...?\n            observer.disconnect(parent)\n            onUnmount(node, node)\n          }\n        })\n      })\n    }\n  )\n\n  observer.observe(parent, { childList: true, subtree: true })\n}\n\n/**\n * Validate a custom tag.\n *\n * Since Remount can work with either Custom Elements or MutationObserver API's,\n * it'd be wise if we rejected element names that won't work in Custom Elements\n * mode (even if we're using MutationObserver mode).\n *\n * @param {string} elName\n * @returns {boolean}\n *\n * @example\n *     isValidName('div')      // => false\n *     isValidName('my-div')   // => true\n *     isValidName('123-456')  // => false\n *     isValidName('my-123')   // => true\n *\n * @private\n */\n\nfunction isValidName(elName) {\n  return !!(elName.indexOf('-') !== -1 && elName.match(/^[a-z][a-z0-9-]*$/))\n}\n\n/**\n * Shadow DOM is not supported with the Mutation Observer strategy.\n */\n\nexport function supportsShadow() {\n  return false\n}\n\n/**\n * Checks if a given Node is an HTMLElement.\n *\n * It's possible that a mutation's `addedNodes` return something that isn't an\n * HTMLElement.\n *\n * @param {any} node\n * @returns {node is HTMLElement}\n */\n\nfunction isElement(node) {\n  if (node) {\n    return true\n  }\n  return false\n}\n","// @ts-check\n/** @typedef { import('./types').Adapter } Adapter */\n/** @typedef { import('./types').Component } Component */\n/** @typedef { import('./types').Defaults } Defaults */\n/** @typedef { import('./types').ElementMap } ElementMap */\n/** @typedef { import('./types').ElementSpec } ElementSpec */\n/** @typedef { import('./types').PropertyMap } PropertyMap */\n/** @typedef { import('./types').Strategy } Strategy */\n\nimport * as CustomElementsStrategy from './strategies/custom_elements'\nimport * as MutationObserverStrategy from './strategies/mutation_observer'\n\n/**\n * Cache of the strategy determined by `getStrategy()`.\n * @type {Strategy | null | undefined}\n */\n\nlet cachedStrategy\n\n/**\n * Detect what API can be used.\n *\n * @example\n *     Remount.getStrategy().name\n */\n\nexport function getStrategy() {\n  if (cachedStrategy) {\n    return cachedStrategy\n  }\n\n  const StrategyUsed = [CustomElementsStrategy, MutationObserverStrategy].find(\n    (strategy) => !!strategy.isSupported()\n  )\n\n  if (!StrategyUsed) {\n    /* tslint:disable no-console */\n    console.warn(\n      \"Remount: This browser doesn't support the \" +\n      'MutationObserver API or the Custom Elements API. Including ' +\n      'polyfills might fix this. Remount elements will not work. ' +\n      'https://github.com/rstacruz/remount'\n    )\n  }\n\n  cachedStrategy = StrategyUsed\n  return StrategyUsed\n}\n\n/**\n * Registers custom elements and links them to React components.\n * @param {ElementMap} components\n * @param {Defaults=} defaults\n *\n * @example\n *     define({ 'x-tooltip': Tooltip })\n *\n * @example\n *     define(\n *       { 'x-tooltip': Tooltip },\n *       { attributes: ['title', 'body'] }\n *     )\n */\n\nexport function define(components, defaults) {\n  const Strategy = getStrategy()\n  if (!Strategy) {\n    return\n  }\n\n  Object.keys(components).forEach((/** @type string */ name) => {\n    // Construct the specs for the element.\n    // (eg, { component: Tooltip, attributes: ['title'] })\n    /** @type ElementSpec */\n    const elSpec = Object.assign({}, defaults, toElementSpec(components[name]))\n\n    /** @type Adapter | null | undefined */\n    const adapter = elSpec.adapter\n    if (!adapter) throw new Error('No suitable adapter found')\n\n    // Define a custom element.\n    Strategy.defineElement(elSpec, name, {\n      onMount(element, mountPoint) {\n        const props = getProps(element, elSpec.attributes)\n        if (elSpec.shadow && elSpec.retarget) {\n          adapter.mount(elSpec, mountPoint, props, element)\n        } else {\n          adapter.mount(elSpec, mountPoint, props, null)\n        }\n      },\n\n      onUpdate(element, mountPoint) {\n        const props = getProps(element, elSpec.attributes)\n        adapter.update(elSpec, mountPoint, props, null)\n      },\n\n      onUnmount(element, mountPoint) {\n        adapter.unmount(elSpec, mountPoint)\n      }\n    })\n  })\n}\n\n/**\n * Coerces something into an `ElementSpec` type.\n *\n * @param {ElementSpec | Component} thing\n * @returns {ElementSpec}\n * @private\n *\n * @example\n *     toElementSpec(Tooltip)\n *     // => { component: Tooltip }\n *\n *     toElementSpec({ component: Tooltip })\n *     // => { component: Tooltip }\n */\n\nfunction toElementSpec(thing) {\n  if (isElementSpec(thing)) {\n    return thing\n  }\n  return { component: thing }\n}\n\n/**\n * Checks if a given `spec` is an ElementSpec.\n *\n * @param {any} spec\n * @returns {spec is ElementSpec}\n */\n\nfunction isElementSpec(spec) {\n  return typeof spec === 'object' && spec.component\n}\n\n/**\n * Returns properties for a given HTML element.\n *\n * @private\n * @param {HTMLElement} element\n * @param {string[] | null | undefined} attributes\n *\n * @example\n *     getProps(div, ['name'])\n *     // => { name: 'Romeo' }\n */\n\nfunction getProps(element, attributes) {\n  const rawJson = element.getAttribute('props-json')\n  if (rawJson) {\n    return JSON.parse(rawJson)\n  }\n\n  const names = attributes || []\n  return names.reduce(\n    (/** @type PropertyMap */ result, /** @type string */ attribute) => {\n      result[attribute] = element.getAttribute(attribute)\n      return result\n    },\n    {}\n  )\n}\n\n/**\n * @param {Adapter} adapter\n */\n\nexport function defineWithAdapter(adapter) {\n  return (\n    /* @type {ElementMap} */ components = {},\n    /** @type {Defaults} */ options = {}\n  ) => define(components, { adapter, ...options })\n}\n","var reactEvents = [\"onAbort\", \"onAnimationCancel\", \"onAnimationEnd\", \"onAnimationIteration\", \"onAuxClick\", \"onBlur\",\n    \"onChange\", \"onClick\", \"onClose\", \"onContextMenu\", \"onDoubleClick\", \"onError\", \"onFocus\", \"onGotPointerCapture\",\n    \"onInput\", \"onKeyDown\", \"onKeyPress\", \"onKeyUp\", \"onLoad\", \"onLoadEnd\", \"onLoadStart\", \"onLostPointerCapture\",\n    \"onMouseDown\", \"onMouseMove\", \"onMouseOut\", \"onMouseOver\", \"onMouseUp\", \"onPointerCancel\", \"onPointerDown\",\n    \"onPointerEnter\", \"onPointerLeave\", \"onPointerMove\", \"onPointerOut\", \"onPointerOver\", \"onPointerUp\", \"onReset\",\n    \"onResize\", \"onScroll\", \"onSelect\", \"onSelectionChange\", \"onSelectStart\", \"onSubmit\", \"onTouchCancel\",\n    \"onTouchMove\", \"onTouchStart\", \"onTouchEnd\",\"onTransitionCancel\", \"onTransitionEnd\", \"onDrag\", \"onDragEnd\",\n    \"onDragEnter\", \"onDragExit\", \"onDragLeave\", \"onDragOver\", \"onDragStart\", \"onDrop\", \"onFocusOut\"];\n\nvar divergentNativeEvents = {\n    onDoubleClick: 'dblclick'\n};\n\nvar mimickedReactEvents = {\n    onInput: 'onChange',\n    onFocusOut: 'onBlur',\n    onSelectionChange: 'onSelect'\n};\n\nmodule.exports = function retargetEvents(shadowRoot) {\n    var removeEventListeners = [];\n\n    reactEvents.forEach(function (reactEventName) {\n\n        var nativeEventName = getNativeEventName(reactEventName);\n\n        function retargetEvent(event) {\n\n            var path = event.path || (event.composedPath && event.composedPath()) || composedPath(event.target);\n\n            for (var i = 0; i < path.length; i++) {\n\n                var el = path[i];\n                var props = null;\n                var reactComponent = findReactComponent(el);\n                var eventHandlers = findReactEventHandlers(el);\n\n                if (!eventHandlers) {\n                    props = findReactProps(reactComponent);\n                } else {\n                    props = eventHandlers;\n                }\n\n                if (reactComponent && props) {\n                    dispatchEvent(event, reactEventName, props);\n                }\n\n                if (reactComponent && props && mimickedReactEvents[reactEventName]) {\n                    dispatchEvent(event, mimickedReactEvents[reactEventName], props);\n                }\n\n                if (event.cancelBubble) {\n                    break;\n                }\n\n                if (el === shadowRoot) {\n                    break;\n                }\n            }\n        }\n\n        shadowRoot.addEventListener(nativeEventName, retargetEvent, false);\n\n        removeEventListeners.push(function () { shadowRoot.removeEventListener(nativeEventName, retargetEvent, false); })\n    });\n\n    return function () {\n\n      removeEventListeners.forEach(function (removeEventListener) {\n\n        removeEventListener();\n      });\n    };\n};\n\nfunction findReactEventHandlers(item) {\n    return findReactProperty(item, '__reactEventHandlers');\n}\n\nfunction findReactComponent(item) {\n    return findReactProperty(item, '_reactInternal');\n}\n\nfunction findReactProperty(item, propertyPrefix) {\n    for (var key in item) {\n        if (item.hasOwnProperty(key) && key.indexOf(propertyPrefix) !== -1) {\n            return item[key];\n        }\n    }\n}\n\nfunction findReactProps(component) {\n    if (!component) return undefined;\n    if (component.memoizedProps) return component.memoizedProps; // React 16 Fiber\n    if (component._currentElement && component._currentElement.props) return component._currentElement.props; // React <=15\n\n}\n\nfunction dispatchEvent(event, eventType, componentProps) {\n    event.persist = function() {\n        event.isPersistent = function(){ return true};\n    };\n\n    if (componentProps[eventType]) {\n        componentProps[eventType](event);\n    }\n}\n\nfunction getNativeEventName(reactEventName) {\n    if (divergentNativeEvents[reactEventName]) {\n        return divergentNativeEvents[reactEventName];\n    }\n    return reactEventName.replace(/^on/, '').toLowerCase();\n}\n\nfunction composedPath(el) {\n  var path = [];\n  while (el) {\n    path.push(el);\n    if (el.tagName === 'HTML') {\n      path.push(document);\n      path.push(window);\n      return path;\n    }\n    el = el.parentElement;\n  }\n}\n","// @ts-check\n/*\n * Adapter for React 18.\n */\n\n/** @typedef { import('../types').ElementSpec } ElementSpec */\n\nimport React from 'react'\nimport { createRoot } from 'react-dom/client'\nimport retargetEvents from 'react-shadow-dom-retarget-events'\n\n/**\n * @param {ElementSpec} elSpec\n * @param {HTMLElement} mountPoint\n * @param {object} props\n * @param {HTMLElement | null} element\n */\n\nexport function mount(elSpec, mountPoint, props, element) {\n  return update(elSpec, mountPoint, props, element)\n}\n\n/**\n * Updates a custom element by calling `ReactDOM.render()`.\n * @private\n *\n * @param {ElementSpec} elSpec\n * @param {HTMLElement & { __remountRoot?: any }} mountPoint\n * @param {object} props\n * @param {HTMLElement | null} element\n */\n\nexport function update(elSpec, mountPoint, props, element) {\n  const { component } = elSpec\n  const reactElement = React.createElement(component, props)\n  const root = createRoot(mountPoint)\n  /** @type {any} */ mountPoint.__remountRoot = root\n  root.render(reactElement)\n  if (element) {\n    retargetEvents(element.shadowRoot)\n  }\n}\n\n/**\n * Unmounts a component.\n * @private\n *\n * @param {ElementSpec} _elSpec\n * @param {HTMLElement & { __remountRoot?: any }} mountPoint\n */\n\nexport function unmount(_elSpec, mountPoint) {\n  mountPoint.__remountRoot?.unmount()\n}\n","/** @typedef { import('./types').ElementMap } ElementMap */\n/** @typedef { import('./types').Defaults } Defaults */\n\nimport { defineWithAdapter, getStrategy } from './core'\nimport * as ReactAdapter from './adapters/react'\n\nconst define = defineWithAdapter(ReactAdapter)\n\n// Alias for doing `import Remount from 'remount'` rather than `import * as Remount`\nconst Remount = { define, getStrategy }\nexport { define, getStrategy, Remount as default }\n"],"names":["elSpec","elName","events","onUpdate","onUnmount","onMount","window","HTMLElement","_babelES5Adapter","Reflect","customElements","hasOwnProperty","a","construct","this","constructor","prototype","Object","setPrototypeOf","enableBabelClasses","attributes","ComponentElement","observedAttributes","connectedCallback","_mountPoint","element","shadow","attachShadow","mountPoint","document","createElement","mode","appendChild","createMountPoint","disconnectedCallback","attributeChangedCallback","quiet","get","define","isSupported","supportsShadow","body","each","list","fn","i","len","length","name","observers","checkForMount","node","nodeName","toLowerCase","MutationObserver","mutations","mutation","targetNode","target","isElement","observe","observeForUpdates","parent","parentNode","observer","removedNodes","subnode","disconnect","childList","subtree","observeForRemoval","children","defineElement","indexOf","match","isValidName","Error","addedNodes","addEventListener","getElementsByTagName","cachedStrategy","getStrategy","StrategyUsed","CustomElementsStrategy","MutationObserverStrategy","find","strategy","console","warn","getProps","rawJson","getAttribute","JSON","parse","reduce","result","attribute","reactEvents","divergentNativeEvents","onDoubleClick","mimickedReactEvents","onInput","onFocusOut","onSelectionChange","findReactProperty","item","propertyPrefix","key","findReactProps","component","memoizedProps","_currentElement","props","dispatchEvent","event","eventType","componentProps","persist","isPersistent","update","reactElement","React","root","createRoot","shadowRoot","removeEventListeners","__remountRoot","render","forEach","reactEventName","nativeEventName","replace","getNativeEventName","retargetEvent","path","composedPath","el","push","tagName","parentElement","reactComponent","cancelBubble","removeEventListener","adapter","unmount","_elSpec","_mountPoint$__remount","components","options","defaults","Strategy","keys","assign","spec","thing","mount","retarget","defineWithAdapter","Remount"],"mappings":"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"}